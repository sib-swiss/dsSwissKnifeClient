% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dssSubsetByClass.R
\name{dssSubsetByClass}
\alias{dssSubsetByClass}
\title{Subset any number of vectors and/or dataframes by the levels of a factor}
\usage{
dssSubsetByClass(
  x,
  subsets = "subClasses",
  variables = NULL,
  keep.cols = NULL,
  async = TRUE,
  datasources = NULL
)
}
\arguments{
\item{x}{a vector containing one or more names of vectors or dataframes present on the remote nodes}

\item{subsets}{a character, name of the new list containing the subsets - default "subClasses"}

\item{variables}{a vector containing one or more names of dataframe columns or standalone factors by which to subset}

\item{keep.cols}{a vector containing the names of the columns or vectors to keep in the result (by default all are kept)}

\item{async}{same as in datashield.assign}

\item{datasources}{same as in datashield.assign}
}
\value{
It doesn't return anything of value, it creates a list containing dataframes (as many as the combinations of categories of "variables") on each node
}
\description{
Alternative to the datashield function ds.SubsetByClass
}
\examples{
# open a local pseudo connection:
opals <-  dssCreatePseudoServers('test', servers = 1)
# load iris and create a vector and a factor:
datashield.aggregate(opals[1], as.symbol('partialData("iris", 41, 150)'))
play_env <- opals$local1$envir
assign('a', play_env$iris$Petal.Length, envir = play_env)
assign('b', factor(c(rep('category1',10), rep('category2',100))), envir = play_env)
#now play around:
dssSubsetByClass('iris', variables = 'iris$Species', datasources = opals)
str(play_env$subClasses)
dssSubsetByClass('iris', variables = c('iris$Species', 'b'), datasources = opals)
str(play_env$subClasses)
dssSubsetByClass(c('iris', 'a'), variables = c('iris$Species', 'b'), keep.cols = c('Sepal.Length', 'Sepal.Width', 'a'), datasources = opals)
str(play_env$subClasses)
dssSubsetByClass('a', variables = 'b', keep.cols = c('a'), datasources = opals)
str(play_env$subClasses)

}
