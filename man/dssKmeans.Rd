% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dssKmeans.R
\name{dssKmeans}
\alias{dssKmeans}
\title{Kmeans on datashield nodes}
\usage{
dssKmeans(
  what,
  centers,
  iter.max = 10,
  nstart = 1,
  type = "combine",
  algorithm = "Forgy",
  async = TRUE,
  datasources = NULL
)
}
\arguments{
\item{what}{a character, name of the dataframe (it can contain non-numerics in which case only the numeric columns will be used)}

\item{centers}{either a number (k - the number of clusters) or a matrix representing the initial number of initial distinct cluster centers (same as for kmeans)}

\item{iter.max}{same as kmeans, maximum number of iterations}

\item{nstart}{same as kmeans, if centers is a number, how many random sets should be chosen}

\item{type}{a character, 'split' or 'combine', should it find the global cluster centers or one set for each node? Default 'combine'.}

\item{algorithm}{same as kmeans, it defaults to "Forgy" as it's the only one that doesn't error out in the case of empty clusters}

\item{async}{same as in datashield.assign}

\item{datasources}{same as in datashield.assign}
}
\value{
A list containing one (in the case of 'combined') or more ('split') stripped down kmeans objects.
}
\description{
Runs kmeans on the remote data, returns a kmeans object representing the cluster centers in either split or combined mode
}
\details{
If type = 'split' the function simply executes kmeans with the provided arguments and returns one set of cluster centers for each node.
If type = 'combine', and centers are provided as a number it first chooses a set of random initial centers from the ranges of the combined dataset, then
it executes exactly one iteration of kmeans (with these initial centers) on each node. The results are then retrieved, averaged and the newly obtained centers
are sent to the nodes for a new iteration. The process continues until iter.max is reached. If nstart > 1 (recommended for any meaningful results), a new random set of initial centers
is calculated and so on until nstart is reached. Then the 'best' cluster centers are chosen as being the ones with the lowest within cluster sum of squared distances.
In both cases ('split' and 'combine') a factor representing the cluster membership of each point is created on the nodes. The name of the factor is derived
from the dataframe name: <dataframe name>_km_clust<number of clusters>.
If iter.max is 0 and centers is a matrix the function simply creates the cluster membership factor (as above) using the given centers.
}
\examples{
# open a local pseudo connection:
opals <-  dssCreatePseudoServers( servers = 2, tie_first_to_GlobalEnv = TRUE)
#load 2 chunks of iris, one on each node:
datashield.aggregate(opals[1], as.symbol('partialData("iris", 1, 70)'))
datashield.aggregate(opals[2], as.symbol('partialData("iris", 71, 150)'))
#combined kmeans:
my.kmeans <- dssKmeans('iris', centers = 3, iter.max =30, nstart = 30, type = 'combine', datasources = opals)
#compare it with simple kmeans on iris:
data("iris")
#kmeans allows only numeric data, so no 'Species', hence iris[,1:4]
local.kmeans <- kmeans(iris[,1:4], centers = 3, iter.max = 30, nstart = 30, algorithm = 'Forgy')
my.kmeans$global$centers
local.kmeans$centers

}
