% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dssSubset.R
\name{dssSubset}
\alias{dssSubset}
\title{Subset a dataframe using free filters}
\usage{
dssSubset(
  symbol,
  what,
  row.filter = TRUE,
  col.filter = TRUE,
  async = TRUE,
  datasources = NULL
)
}
\arguments{
\item{symbol}{the name of the new dataframe}

\item{what}{the name of the source dataframe}

\item{row.filter}{a character containing the row filtering conditions. The filter is executed in the dataframe environment so no need to
qualify the column names. Ex: .... row.filter = "LBTESTCD == 'HDL'"}

\item{col.filter}{a character containing the column filtering conditions. Ex: "c('LBTESTCD', 'LBORRES')"}

\item{async}{same as in datashield.assign}

\item{datasources}{same as in datashield.assign}
}
\value{
It doesn't return anything,  it creates a filtered dataframe on the remote node
}
\description{
Alternative to the datashield function ds.subset
}
\examples{
# open a local pseudo connection:
library(DSLite)
dslite.server1 <<- newDSLiteServer(config = defaultDSConfiguration(include=c('dsSwissKnife')))
builder <- newDSLoginBuilder()
builder$append(server="server1", url='dslite.server1',driver = "DSLiteDriver")
logindata <- builder$build()
opals <- datashield.login(logins = logindata)
# load iris
datashield.aggregate(opals[1], as.symbol('partialData("iris")'))
# put a label on the pseudo-remote session so we can retrieve it later:
session1 <- dslite.server1$getSession(dslite.server1$getSessionIds())
# now play around:
dssSubset('iris_filtered', 'iris', row.filter = 'Sepal.Length < 6 & Species == "setosa"', col.filter = '!(colnames(iris) == "Petal.Width")', datasources = opals)
str(session1$iris_filtered)

}
