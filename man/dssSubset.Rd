% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dssSubset.R
\name{dssSubset}
\alias{dssSubset}
\title{Subset a dataframe using free filters}
\usage{
dssSubset(
  symbol,
  what,
  row.filter = TRUE,
  col.filter = TRUE,
  async = TRUE,
  datasources = NULL
)
}
\arguments{
\item{symbol}{the name of the new dataframe}

\item{what}{the name of the source dataframe}

\item{row.filter}{a character containing the row filtering conditions. The filter is executed in the dataframe environment so no need to
qualify the column names. Ex: .... row.filter = "LBTESTCD == 'HDL'"}

\item{col.filter}{a character containing the column filtering conditions. Ex: "c('LBTESTCD', 'LBORRES')"}

\item{async}{same as in datashield.assign}

\item{datasources}{same as in datashield.assign}
}
\value{
It doesn't return anything,  it creates a filtered dataframe on the remote node
}
\description{
Alternative to the datashield function ds.subset
}
\examples{
# open a local pseudo connection:
opals <- dssCreatePseudoServers(servers = 1, tie_first_to_GlobalEnv = TRUE)
# load iris
data('iris')
# now play around:
dssSubset('iris_filtered', 'iris', row.filter = 'Sepal.Length < 6 & Species == "setosa"', col.filter = '!(colnames(iris) == "Petal.Width")', datasources = opals)
str(iris_filtered)

}
